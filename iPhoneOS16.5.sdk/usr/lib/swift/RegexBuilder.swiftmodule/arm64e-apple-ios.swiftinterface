// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8 (swiftlang-5.8.0.117.59 clang-1403.0.22.8.50)
// swift-module-flags: -target arm64e-apple-ios16.4 -enable-objc-interop -enable-library-evolution -module-link-name swiftRegexBuilder -swift-version 5 -O -library-level api -enforce-exclusivity=unchecked -module-name RegexBuilder
// swift-module-flags-ignorable: -enable-lexical-lifetimes=false -target-min-inlining-version min -user-module-version 5.8.0.117.59
import Swift
import _StringProcessing
extension Swift.BidirectionalCollection where Self.SubSequence == Swift.Substring {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func wholeMatch<Output>(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent<Output>) -> _StringProcessing.Regex<Output>.Match?
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func prefixMatch<Output>(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent<Output>) -> _StringProcessing.Regex<Output>.Match?
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func contains(@RegexBuilder.RegexComponentBuilder _ content: () -> some RegexComponent) -> Swift.Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func firstRange(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent) -> Swift.Range<Self.Index>?
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func ranges(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent) -> [Swift.Range<Self.Index>]
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, @RegexBuilder.RegexComponentBuilder separator: () -> some RegexComponent) -> [Self.SubSequence]
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func starts(@RegexBuilder.RegexComponentBuilder with content: () -> some RegexComponent) -> Swift.Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func trimmingPrefix(@RegexBuilder.RegexComponentBuilder _ content: () -> some RegexComponent) -> Self.SubSequence
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func firstMatch<Output>(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent<Output>) -> _StringProcessing.Regex<Output>.Match?
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func matches<Output>(@RegexBuilder.RegexComponentBuilder of content: () -> some RegexComponent<Output>) -> [_StringProcessing.Regex<Output>.Match]
}
extension Swift.RangeReplaceableCollection where Self : Swift.BidirectionalCollection, Self.SubSequence == Swift.Substring {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public mutating func trimPrefix(@RegexBuilder.RegexComponentBuilder _ content: () -> some RegexComponent)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func replacing<Replacement>(with replacement: Replacement, subrange: Swift.Range<Self.Index>, maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent) -> Self where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func replacing<Replacement>(with replacement: Replacement, maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent) -> Self where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public mutating func replace<Replacement>(with replacement: Replacement, maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent) where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func replacing<Output, Replacement>(subrange: Swift.Range<Self.Index>, maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent<Output>, with replacement: (_StringProcessing.Regex<Output>.Match) throws -> Replacement) rethrows -> Self where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func replacing<Output, Replacement>(maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent<Output>, with replacement: (_StringProcessing.Regex<Output>.Match) throws -> Replacement) rethrows -> Self where Replacement : Swift.Collection, Replacement.Element == Swift.Character
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public mutating func replace<Output, Replacement>(maxReplacements: Swift.Int = .max, @RegexBuilder.RegexComponentBuilder content: () -> some RegexComponent<Output>, with replacement: (_StringProcessing.Regex<Output>.Match) throws -> Replacement) rethrows where Replacement : Swift.Collection, Replacement.Element == Swift.Character
}
extension Swift.StringProtocol where Self.SubSequence == Swift.Substring {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func split(separator: Swift.String, maxSplits: Swift.Int = .max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.Substring]
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func split(separator: Swift.Substring, maxSplits: Swift.Int = .max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.Substring]
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Anchor {
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Anchor : _StringProcessing.RegexComponent {
  public var regex: _StringProcessing.Regex<Swift.Substring> {
    get
  }
  public typealias RegexOutput = Swift.Substring
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Anchor {
  public static var startOfSubject: RegexBuilder.Anchor {
    get
  }
  public static var endOfSubjectBeforeNewline: RegexBuilder.Anchor {
    get
  }
  public static var endOfSubject: RegexBuilder.Anchor {
    get
  }
  public static var firstMatchingPositionInSubject: RegexBuilder.Anchor {
    get
  }
  public static var textSegmentBoundary: RegexBuilder.Anchor {
    get
  }
  public static var startOfLine: RegexBuilder.Anchor {
    get
  }
  public static var endOfLine: RegexBuilder.Anchor {
    get
  }
  public static var wordBoundary: RegexBuilder.Anchor {
    get
  }
  public var inverted: RegexBuilder.Anchor {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Lookahead<Output> {
  public var regex: _StringProcessing.Regex<Output>
  public init<R>(_ component: R) where Output == R.RegexOutput, R : _StringProcessing.RegexComponent
  public init<R>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == R.RegexOutput, R : _StringProcessing.RegexComponent
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct NegativeLookahead<Output> {
  public var regex: _StringProcessing.Regex<Output>
  public init<R>(_ component: R) where Output == R.RegexOutput, R : _StringProcessing.RegexComponent
  public init<R>(@RegexBuilder.RegexComponentBuilder _ component: () -> R) where Output == R.RegexOutput, R : _StringProcessing.RegexComponent
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_functionBuilder public enum RegexComponentBuilder {
  public static func buildBlock() -> _StringProcessing.Regex<Swift.Substring>
  public static func buildPartialBlock<R>(first component: R) -> _StringProcessing.Regex<R.RegexOutput> where R : _StringProcessing.RegexComponent
  public static func buildExpression<R>(_ regex: R) -> R where R : _StringProcessing.RegexComponent
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct CharacterClass {
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.CharacterClass : _StringProcessing.RegexComponent {
  public var regex: _StringProcessing.Regex<Swift.Substring> {
    get
  }
  public typealias RegexOutput = Swift.Substring
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.CharacterClass {
  public var inverted: RegexBuilder.CharacterClass {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.RegexComponent where Self == RegexBuilder.CharacterClass {
  public static var any: RegexBuilder.CharacterClass {
    get
  }
  public static var anyNonNewline: RegexBuilder.CharacterClass {
    get
  }
  public static var anyGraphemeCluster: RegexBuilder.CharacterClass {
    get
  }
  public static var digit: RegexBuilder.CharacterClass {
    get
  }
  public static var hexDigit: RegexBuilder.CharacterClass {
    get
  }
  public static var word: RegexBuilder.CharacterClass {
    get
  }
  public static var whitespace: RegexBuilder.CharacterClass {
    get
  }
  public static var horizontalWhitespace: RegexBuilder.CharacterClass {
    get
  }
  public static var newlineSequence: RegexBuilder.CharacterClass {
    get
  }
  public static var verticalWhitespace: RegexBuilder.CharacterClass {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.RegexComponent where Self == RegexBuilder.CharacterClass {
  public static func anyOf<S>(_ s: S) -> RegexBuilder.CharacterClass where S : Swift.Sequence, S.Element == Swift.Character
  public static func anyOf<S>(_ s: S) -> RegexBuilder.CharacterClass where S : Swift.Sequence, S.Element == Swift.Unicode.Scalar
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.CharacterClass {
  public static func generalCategory(_ category: Swift.Unicode.GeneralCategory) -> RegexBuilder.CharacterClass
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public func ... (lhs: Swift.Character, rhs: Swift.Character) -> RegexBuilder.CharacterClass
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_disfavoredOverload public func ... (lhs: Swift.UnicodeScalar, rhs: Swift.UnicodeScalar) -> RegexBuilder.CharacterClass
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.RegexComponent where Self == RegexBuilder.CharacterClass {
  public init(_ first: RegexBuilder.CharacterClass, _ rest: RegexBuilder.CharacterClass...)
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.CharacterClass {
  public func union(_ other: RegexBuilder.CharacterClass) -> RegexBuilder.CharacterClass
  public func intersection(_ other: RegexBuilder.CharacterClass) -> RegexBuilder.CharacterClass
  public func subtracting(_ other: RegexBuilder.CharacterClass) -> RegexBuilder.CharacterClass
  public func symmetricDifference(_ other: RegexBuilder.CharacterClass) -> RegexBuilder.CharacterClass
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.Regex {
  public init(@RegexBuilder.RegexComponentBuilder _ content: () -> some RegexComponent<Output>)
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.String : _StringProcessing.RegexComponent {
  public typealias Output = Swift.Substring
  public var regex: _StringProcessing.Regex<Swift.String.Output> {
    get
  }
  public typealias RegexOutput = Swift.String.Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Substring : _StringProcessing.RegexComponent {
  public typealias Output = Swift.Substring
  public var regex: _StringProcessing.Regex<Swift.Substring.Output> {
    get
  }
  public typealias RegexOutput = Swift.Substring.Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Character : _StringProcessing.RegexComponent {
  public typealias Output = Swift.Substring
  public var regex: _StringProcessing.Regex<Swift.Character.Output> {
    get
  }
  public typealias RegexOutput = Swift.Character.Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Unicode.Scalar : _StringProcessing.RegexComponent {
  public typealias Output = Swift.Substring
  public var regex: _StringProcessing.Regex<Swift.Unicode.Scalar.Output> {
    get
  }
  public typealias RegexOutput = Swift.Unicode.Scalar.Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct One<Output> : _StringProcessing.RegexComponent {
  public var regex: _StringProcessing.Regex<Output>
  public init(_ component: some RegexComponent<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct OneOrMore<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct ZeroOrMore<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Optionally<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Repeat<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_functionBuilder public struct AlternationBuilder {
  @_disfavoredOverload public static func buildPartialBlock<R>(first component: R) -> RegexBuilder.ChoiceOf<R.RegexOutput> where R : _StringProcessing.RegexComponent
  public static func buildExpression<R>(_ regex: R) -> R where R : _StringProcessing.RegexComponent
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct ChoiceOf<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public init(@RegexBuilder.AlternationBuilder _ builder: () -> RegexBuilder.ChoiceOf<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Capture<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct TryCapture<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Local<Output> {
  public var regex: _StringProcessing.Regex<Output>
  @usableFromInline
  internal init(_ regex: _StringProcessing.Regex<Output>)
  public typealias RegexOutput = Output
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Reference<Capture> : _StringProcessing.RegexComponent {
  public init(_ captureType: Capture.Type = Capture.self)
  @usableFromInline
  internal var _raw: Swift.Int {
    get
  }
  public var regex: _StringProcessing.Regex<Capture> {
    get
  }
  public typealias RegexOutput = Capture
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _StringProcessing.Regex.Match {
  public subscript<Capture>(reference: RegexBuilder.Reference<Capture>) -> Capture {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@usableFromInline
internal func makeFactory() -> _StringProcessing._RegexFactory
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1)>) -> _StringProcessing.Regex<(Swift.Substring, C1)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1, C2)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1, C2, C3)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1, C2, C3, C4)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1, C2, C3, C4, C5)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6, C7)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6, C7, C8)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<W0>, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6, C7)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6, C7, C8)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6, C7, C8, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6, C7)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6, C7, C8)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6, C7, C8, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6, C7, C8, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6, C7)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6, C7, C8)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6, C7, C8, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6, C7, C8, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6, C7)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6, C7, C8)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6, C7, C8, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6, C7, C8, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6, C7)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6, C7, C8)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6, C7, C8, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6, C7, C8, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent<(W1, C7)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent<(W1, C7, C8)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent<(W1, C7, C8, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent<(W1, C7, C8, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7)>, next: some RegexComponent<(W1, C8)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7)>, next: some RegexComponent<(W1, C8, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7)>, next: some RegexComponent<(W1, C8, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7, C8)>, next: some RegexComponent<(W1, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7, C8)>, next: some RegexComponent<(W1, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, next: some RegexComponent<(W1, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0>(accumulated: some RegexComponent<W0>, next: some RegexComponent) -> _StringProcessing.Regex<Swift.Substring> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0>(accumulated: some RegexComponent<(W0, C0)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1>(accumulated: some RegexComponent<(W0, C0, C1)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0, C1)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2>(accumulated: some RegexComponent<(W0, C0, C1, C2)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3>(accumulated: some RegexComponent<(W0, C0, C1, C2, C3)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4>(accumulated: some RegexComponent<(W0, C0, C1, C2, C3, C4)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5>(accumulated: some RegexComponent<(W0, C0, C1, C2, C3, C4, C5)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent<(W0, C0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C0, C1, C2, C3, C4, C5, C6, C7)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C0, C1, C2, C3, C4, C5, C6, C7, C8)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, next: some RegexComponent) -> _StringProcessing.Regex<(Swift.Substring, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return factory.accumulate(accumulated, next)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ component: some RegexComponent, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability(_ component: some RegexComponent) -> _StringProcessing.Regex<Swift.Substring> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ component: some RegexComponent, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ component: some RegexComponent, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ component: some RegexComponent, count: Swift.Int) where Output == Swift.Substring {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent) where Output == Swift.Substring {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ component: some RegexComponent, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1>(_ component: some RegexComponent<(W, C1)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>) where Output == (Swift.Substring, C1?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1>(_ component: some RegexComponent<(W, C1)>) -> _StringProcessing.Regex<(Swift.Substring, C1?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1>(_ component: some RegexComponent<(W, C1)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>) where Output == (Swift.Substring, C1?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1>(_ component: some RegexComponent<(W, C1)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>) where Output == (Swift.Substring, C1) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1>(_ component: some RegexComponent<(W, C1)>, count: Swift.Int) where Output == (Swift.Substring, C1?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>) where Output == (Swift.Substring, C1?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1>(_ component: some RegexComponent<(W, C1)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>) where Output == (Swift.Substring, C1?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ component: some RegexComponent<(W, C1, C2)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, C1?, C2?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2>(_ component: some RegexComponent<(W, C1, C2)>) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ component: some RegexComponent<(W, C1, C2)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, C1?, C2?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ component: some RegexComponent<(W, C1, C2)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, C1, C2) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ component: some RegexComponent<(W, C1, C2)>, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, C1?, C2?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ component: some RegexComponent<(W, C1, C2)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, C1?, C2?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ component: some RegexComponent<(W, C1, C2, C3)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, C1?, C2?, C3?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3>(_ component: some RegexComponent<(W, C1, C2, C3)>) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ component: some RegexComponent<(W, C1, C2, C3)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, C1?, C2?, C3?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ component: some RegexComponent<(W, C1, C2, C3)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ component: some RegexComponent<(W, C1, C2, C3)>, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, C1?, C2?, C3?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ component: some RegexComponent<(W, C1, C2, C3)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, C1?, C2?, C3?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6, C7>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?) {
    let factory = makeFactory()
    self.init(factory.zeroOrOne(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.RegexComponentBuilder {
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) -> _StringProcessing.Regex<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?)> {
    let factory = makeFactory()
    return factory.zeroOrOne(component, nil)
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?) {
    let factory = makeFactory()
    self.init(factory.zeroOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(component, behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.oneOrMore(componentBuilder(), behavior))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, count: Swift.Int) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(count: Swift.Int, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?) {
    precondition(count >= 0, "Must specify a positive count")
    let factory = makeFactory()
    self.init(factory.exactly(count, componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, _ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ expression: some RangeExpression<Int>, _ behavior: _StringProcessing.RegexRepetitionBehavior? = nil, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?) {
    let factory = makeFactory()
    self.init(factory.repeating(expression.relative(to: 0..<Int.max), behavior, componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_disfavoredOverload @_alwaysEmitIntoClient public init(_ component: some RegexComponent) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_disfavoredOverload @_alwaysEmitIntoClient public init(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent) where Output == Swift.Substring {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1>(_ component: some RegexComponent<(W, C1)>) where Output == (Swift.Substring, C1) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>) where Output == (Swift.Substring, C1) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ component: some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, C1, C2) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, C1, C2) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ component: some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(component))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.atomicNonCapturing(componentBuilder()))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock(accumulated: some RegexComponent, next: some RegexComponent) -> RegexBuilder.ChoiceOf<Swift.Substring> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1, C2>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1, C2)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?, C2?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1, C2, C3>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1, C2, C3)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?, C2?, C3?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1, C2, C3, C4>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1, C2, C3, C4)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?, C2?, C3?, C4?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1, C2, C3, C4, C5>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1, C2, C3, C4, C5)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?, C2?, C3?, C4?, C5?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6, C7)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6, C7, C8)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent, next: some RegexComponent<(W1, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, W1, C2>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, W1, C2, C3>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2?, C3?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, W1, C2, C3, C4>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2?, C3?, C4?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, W1, C2, C3, C4, C5>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2?, C3?, C4?, C5?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, W1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2?, C3?, C4?, C5?, C6?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, W1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6, C7)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2?, C3?, C4?, C5?, C6?, C7?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, W1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6, C7, C8)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2?, C3?, C4?, C5?, C6?, C7?, C8?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, W1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6, C7, C8, C9)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, W1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1)>, next: some RegexComponent<(W1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, W1, C3>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, W1, C3, C4>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3?, C4?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, W1, C3, C4, C5>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3?, C4?, C5?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, W1, C3, C4, C5, C6>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3?, C4?, C5?, C6?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, W1, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6, C7)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3?, C4?, C5?, C6?, C7?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, W1, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6, C7, C8)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3?, C4?, C5?, C6?, C7?, C8?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, W1, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6, C7, C8, C9)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, W1, C3, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2)>, next: some RegexComponent<(W1, C3, C4, C5, C6, C7, C8, C9, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, W1, C4>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, W1, C4, C5>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4?, C5?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, W1, C4, C5, C6>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4?, C5?, C6?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, W1, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6, C7)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4?, C5?, C6?, C7?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, W1, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6, C7, C8)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4?, C5?, C6?, C7?, C8?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, W1, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6, C7, C8, C9)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4?, C5?, C6?, C7?, C8?, C9?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, W1, C4, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3)>, next: some RegexComponent<(W1, C4, C5, C6, C7, C8, C9, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4?, C5?, C6?, C7?, C8?, C9?, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, W1, C5>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, W1, C5, C6>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5?, C6?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, W1, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6, C7)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5?, C6?, C7?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, W1, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6, C7, C8)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5?, C6?, C7?, C8?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, W1, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6, C7, C8, C9)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5?, C6?, C7?, C8?, C9?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, W1, C5, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4)>, next: some RegexComponent<(W1, C5, C6, C7, C8, C9, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5?, C6?, C7?, C8?, C9?, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, W1, C6>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, W1, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6, C7)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6?, C7?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, W1, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6, C7, C8)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6?, C7?, C8?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, W1, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6, C7, C8, C9)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6?, C7?, C8?, C9?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, W1, C6, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5)>, next: some RegexComponent<(W1, C6, C7, C8, C9, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6?, C7?, C8?, C9?, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, W1, C7>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent<(W1, C7)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, W1, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent<(W1, C7, C8)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7?, C8?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, W1, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent<(W1, C7, C8, C9)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7?, C8?, C9?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, W1, C7, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6)>, next: some RegexComponent<(W1, C7, C8, C9, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7?, C8?, C9?, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, C7>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7)>, next: some RegexComponent) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, C7, W1, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7)>, next: some RegexComponent<(W1, C8)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, C7, W1, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7)>, next: some RegexComponent<(W1, C8, C9)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8?, C9?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, C7, W1, C8, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7)>, next: some RegexComponent<(W1, C8, C9, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8?, C9?, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, C7, C8>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7, C8)>, next: some RegexComponent) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, C7, C8, W1, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7, C8)>, next: some RegexComponent<(W1, C9)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, C7, C8, W1, C9, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7, C8)>, next: some RegexComponent<(W1, C9, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9?, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, next: some RegexComponent) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<W0, C1, C2, C3, C4, C5, C6, C7, C8, C9, W1, C10>(accumulated: some RegexComponent<(W0, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, next: some RegexComponent<(W1, C10)>) -> RegexBuilder.ChoiceOf<(Swift.Substring, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10?)> {
    let factory = makeFactory()
    return .init(factory.accumulateAlternation(accumulated, next))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6, C7>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?, C7?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6, C7, C8>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.AlternationBuilder {
  @_alwaysEmitIntoClient public static func buildPartialBlock<R, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(first regex: R) -> RegexBuilder.ChoiceOf<(W, C1?, C2?, C3?, C4?, C5?, C6?, C7?, C8?, C9?, C10?)> where R : _StringProcessing.RegexComponent, R.RegexOutput == (W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    return .init(factory.orderedChoice(regex))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W>(_ component: some RegexComponent<W>) where Output == (Swift.Substring, W) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W>(_ component: some RegexComponent<W>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W, NewCapture>(_ component: some RegexComponent<W>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W, NewCapture>(_ component: some RegexComponent<W>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W, NewCapture>(_ component: some RegexComponent<W>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W, NewCapture>(_ component: some RegexComponent<W>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<W>) where Output == (Swift.Substring, W) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<W>) where Output == (Swift.Substring, W) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<W>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<W>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<W>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public init<W, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<W>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1>(_ component: some RegexComponent<(W, C1)>) where Output == (Swift.Substring, W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1>(_ component: some RegexComponent<(W, C1)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, NewCapture>(_ component: some RegexComponent<(W, C1)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, NewCapture>(_ component: some RegexComponent<(W, C1)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, NewCapture>(_ component: some RegexComponent<(W, C1)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, NewCapture>(_ component: some RegexComponent<(W, C1)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>) where Output == (Swift.Substring, W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>) where Output == (Swift.Substring, W, C1) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ component: some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2>(_ component: some RegexComponent<(W, C1, C2)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, NewCapture>(_ component: some RegexComponent<(W, C1, C2)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, NewCapture>(_ component: some RegexComponent<(W, C1, C2)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, NewCapture>(_ component: some RegexComponent<(W, C1, C2)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, NewCapture>(_ component: some RegexComponent<(W, C1, C2)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>) where Output == (Swift.Substring, W, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ component: some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(_ component: some RegexComponent<(W, C1, C2, C3)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>) where Output == (Swift.Substring, W, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>) where Output == (Swift.Substring, W, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, as reference: RegexBuilder.Reference<W>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(_ component: some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, as reference: RegexBuilder.Reference<NewCapture>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.captureOptional(component, reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder()))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10>(as reference: RegexBuilder.Reference<W>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>) where Output == (Swift.Substring, W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, transform: @escaping (W) throws -> NewCapture) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.capture(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture {
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(@RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), nil, transform))
  }
  @_alwaysEmitIntoClient public init<W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, NewCapture>(as reference: RegexBuilder.Reference<NewCapture>, @RegexBuilder.RegexComponentBuilder _ componentBuilder: () -> some RegexComponent<(W, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10)>, transform: @escaping (W) throws -> NewCapture?) where Output == (Swift.Substring, NewCapture, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) {
    let factory = makeFactory()
    self.init(factory.captureOptional(componentBuilder(), reference._raw, transform))
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Lookahead : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.NegativeLookahead : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.OneOrMore : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ZeroOrMore : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Optionally : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Repeat : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.ChoiceOf : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Capture : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.TryCapture : _StringProcessing.RegexComponent {}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension RegexBuilder.Local : _StringProcessing.RegexComponent {}
