// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2 (swiftlang-1103.2.25.13 clang-1103.2.30.24)
// swift-module-flags: -target arm64e-apple-ios13.7 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name CryptoKit
import Foundation
import LocalAuthentication
import Security.SecAccessControl
import Security
import Swift
extension Curve25519.Signing.PublicKey {
  public func isValidSignature<S, D>(_ signature: S, for data: D) -> Swift.Bool where S : Foundation.DataProtocol, D : Foundation.DataProtocol
}
extension Curve25519.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> Foundation.Data where D : Foundation.DataProtocol
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum Curve25519 {
}
extension P256 {
  public enum Signing {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P256.Signing.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P256 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P256.KeyAgreement.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P384 {
  public enum Signing {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P384.Signing.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P384 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P384.KeyAgreement.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P521 {
  public enum Signing {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P521.Signing.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P521 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P521.KeyAgreement.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P256.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.P256.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
}
extension P384.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.P384.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
}
extension P521.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.P521.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct HMAC<H> where H : CryptoKit.HashFunction {
  public typealias Key = CryptoKit.SymmetricKey
  public typealias MAC = CryptoKit.HashedAuthenticationCode<H>
  public static func isValidAuthenticationCode(_ mac: CryptoKit.HMAC<H>.MAC, authenticating bufferPointer: Swift.UnsafeRawBufferPointer, using key: CryptoKit.SymmetricKey) -> Swift.Bool
  public init(key: CryptoKit.SymmetricKey)
  public static func authenticationCode<D>(for data: D, using key: CryptoKit.SymmetricKey) -> CryptoKit.HMAC<H>.MAC where D : Foundation.DataProtocol
  public static func isValidAuthenticationCode<D>(_ authenticationCode: CryptoKit.HMAC<H>.MAC, authenticating authenticatedData: D, using key: CryptoKit.SymmetricKey) -> Swift.Bool where D : Foundation.DataProtocol
  @available(iOS 13.2, OSX 10.15, watchOS 6.1, tvOS 13.2, *)
  public static func isValidAuthenticationCode<C, D>(_ authenticationCode: C, authenticating authenticatedData: D, using key: CryptoKit.SymmetricKey) -> Swift.Bool where C : Foundation.ContiguousBytes, D : Foundation.DataProtocol
  public mutating func update<D>(data: D) where D : Foundation.DataProtocol
  public func finalize() -> CryptoKit.HMAC<H>.MAC
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct HashedAuthenticationCode<H> : CryptoKit.MessageAuthenticationCode where H : CryptoKit.HashFunction {
  public var byteCount: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public typealias Element = Swift.IndexingIterator<Swift.Array<Swift.UInt8>>.Element
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum P256 {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum P384 {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum P521 {
}
extension HMAC {
  @usableFromInline
  internal static func isValidAuthenticationCode<D>(_ authenticationCode: Foundation.ContiguousBytes, authenticating authenticatedData: D, using key: CryptoKit.SymmetricKey) -> Swift.Bool where D : Foundation.DataProtocol
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public protocol Digest : Foundation.ContiguousBytes, Swift.CustomStringConvertible, Swift.Hashable, Swift.Sequence where Self.Element == Swift.UInt8 {
  static var byteCount: Swift.Int { get }
}
extension Digest {
  public func makeIterator() -> Swift.Array<Swift.UInt8>.Iterator
}
extension Digest {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public static func == <D>(lhs: Self, rhs: D) -> Swift.Bool where D : Foundation.DataProtocol
  public var description: Swift.String {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA256Digest {
  public static var byteCount: Swift.Int {
    get
  }
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias Element = Swift.IndexingIterator<Swift.Array<Swift.UInt8>>.Element
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA384Digest {
  public static var byteCount: Swift.Int {
    get
  }
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias Element = Swift.IndexingIterator<Swift.Array<Swift.UInt8>>.Element
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA512Digest {
  public static var byteCount: Swift.Int {
    get
  }
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias Element = Swift.IndexingIterator<Swift.Array<Swift.UInt8>>.Element
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
}
extension Insecure {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct SHA1Digest {
    public static var byteCount: Swift.Int {
      get
    }
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public typealias Element = Swift.IndexingIterator<Swift.Array<Swift.UInt8>>.Element
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Insecure {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct MD5Digest {
    public static var byteCount: Swift.Int {
      get
    }
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public typealias Element = Swift.IndexingIterator<Swift.Array<Swift.UInt8>>.Element
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SecureEnclave.P256.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> CryptoKit.P256.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension SecureEnclave.P256.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> CryptoKit.P256.Signing.ECDSASignature where D : Foundation.DataProtocol
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum SecureEnclave {
}
extension SecureEnclave {
  public static var isAvailable: Swift.Bool {
    get
  }
  public enum P256 {
    public enum Signing {
      public struct PrivateKey {
        public let publicKey: CryptoKit.P256.Signing.PublicKey
        public let dataRepresentation: Foundation.Data
        @available(iOS 13.0, OSX 10.15, *)
        public init(dataRepresentation: Foundation.Data, authenticationContext: LocalAuthentication.LAContext? = nil) throws
        @available(iOS 13.0, OSX 10.15, *)
        public init(compactRepresentable: Swift.Bool = true, accessControl: Security.SecAccessControl = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, [], nil)!, authenticationContext: LocalAuthentication.LAContext? = nil) throws
      }
    }
    public enum KeyAgreement {
      public struct PrivateKey {
        public let publicKey: CryptoKit.P256.KeyAgreement.PublicKey
        public let dataRepresentation: Foundation.Data
        @available(iOS 13.0, OSX 10.15, *)
        public init(dataRepresentation: Foundation.Data, authenticationContext: LocalAuthentication.LAContext? = nil) throws
        @available(iOS 13.0, OSX 10.15, *)
        public init(compactRepresentable: Swift.Bool = true, accessControl: Security.SecAccessControl = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, [], nil)!, authenticationContext: LocalAuthentication.LAContext? = nil) throws
      }
    }
  }
}
extension SecureEnclave.P256.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.P256.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA256 {
  @available(iOS 13.2, OSX 10.15, watchOS 6.1, tvOS 13.2, *)
  public static var blockByteCount: Swift.Int
  public typealias Digest = CryptoKit.SHA256Digest
  public static var byteCount: Swift.Int
  public init()
  public mutating func update(bufferPointer: Swift.UnsafeRawBufferPointer)
  public func finalize() -> CryptoKit.SHA256.Digest
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA384 {
  @available(iOS 13.2, OSX 10.15, watchOS 6.1, tvOS 13.2, *)
  public static var blockByteCount: Swift.Int
  public typealias Digest = CryptoKit.SHA384Digest
  public static var byteCount: Swift.Int
  public init()
  public mutating func update(bufferPointer: Swift.UnsafeRawBufferPointer)
  public func finalize() -> CryptoKit.SHA384.Digest
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA512 {
  @available(iOS 13.2, OSX 10.15, watchOS 6.1, tvOS 13.2, *)
  public static var blockByteCount: Swift.Int
  public typealias Digest = CryptoKit.SHA512Digest
  public static var byteCount: Swift.Int
  public init()
  public mutating func update(bufferPointer: Swift.UnsafeRawBufferPointer)
  public func finalize() -> CryptoKit.SHA512.Digest
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum Insecure {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum ChaChaPoly {
  public static func seal<Plaintext, AuthenticatedData>(_ message: Plaintext, using key: CryptoKit.SymmetricKey, nonce: CryptoKit.ChaChaPoly.Nonce? = nil, authenticating authenticatedData: AuthenticatedData) throws -> CryptoKit.ChaChaPoly.SealedBox where Plaintext : Foundation.DataProtocol, AuthenticatedData : Foundation.DataProtocol
  public static func seal<Plaintext>(_ message: Plaintext, using key: CryptoKit.SymmetricKey, nonce: CryptoKit.ChaChaPoly.Nonce? = nil) throws -> CryptoKit.ChaChaPoly.SealedBox where Plaintext : Foundation.DataProtocol
  public static func open<AuthenticatedData>(_ sealedBox: CryptoKit.ChaChaPoly.SealedBox, using key: CryptoKit.SymmetricKey, authenticating authenticatedData: AuthenticatedData) throws -> Foundation.Data where AuthenticatedData : Foundation.DataProtocol
  public static func open(_ sealedBox: CryptoKit.ChaChaPoly.SealedBox, using key: CryptoKit.SymmetricKey) throws -> Foundation.Data
}
extension ChaChaPoly {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  @frozen public struct SealedBox {
    public let combined: Foundation.Data
    public var tag: Foundation.Data {
      get
    }
    public var ciphertext: Foundation.Data {
      get
    }
    public var nonce: CryptoKit.ChaChaPoly.Nonce {
      get
    }
    @inlinable public init<D>(combined: D) throws where D : Foundation.DataProtocol {
            // ChachaPoly nonce (12 bytes) + ChachaPoly tag (16 bytes)
            // While we have these values in the internal APIs, we can't use it in inlinable code.
            let chachaPolyOverhead = 12 + 16
            
            if (combined.count < chachaPolyOverhead) {
                throw CryptoKitError.incorrectParameterSize
            }
            
            self.combined = Data(combined)
        }
    public init<C, T>(nonce: CryptoKit.ChaChaPoly.Nonce, ciphertext: C, tag: T) throws where C : Foundation.DataProtocol, T : Foundation.DataProtocol
  }
}
extension AES.GCM {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct Nonce : Foundation.ContiguousBytes, Swift.Sequence {
    public init()
    public init<D>(data: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public func makeIterator() -> Swift.Array<Swift.UInt8>.Iterator
    public typealias Element = Swift.IndexingIterator<Swift.Array<Swift.UInt8>>.Element
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  }
}
extension ChaChaPoly {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct Nonce : Foundation.ContiguousBytes, Swift.Sequence {
    public init()
    public init<D>(data: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public func makeIterator() -> Swift.Array<Swift.UInt8>.Iterator
    public typealias Element = Swift.IndexingIterator<Swift.Array<Swift.UInt8>>.Element
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum AES {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SymmetricKeySize {
  public let bitCount: Swift.Int
  public static var bits128: CryptoKit.SymmetricKeySize {
    get
  }
  public static var bits192: CryptoKit.SymmetricKeySize {
    get
  }
  public static var bits256: CryptoKit.SymmetricKeySize {
    get
  }
  public init(bitCount: Swift.Int)
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SymmetricKey : Foundation.ContiguousBytes {
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public init<D>(data: D) where D : Foundation.ContiguousBytes
  public init(size: CryptoKit.SymmetricKeySize)
  public var bitCount: Swift.Int {
    get
  }
}
extension SymmetricKey : Swift.Equatable {
  public static func == (lhs: CryptoKit.SymmetricKey, rhs: CryptoKit.SymmetricKey) -> Swift.Bool
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public protocol HashFunction {
  @available(iOS 13.2, OSX 10.15, watchOS 6.1, tvOS 13.2, *)
  static var blockByteCount: Swift.Int { get }
  associatedtype Digest : CryptoKit.Digest
  init()
  mutating func update(bufferPointer: Swift.UnsafeRawBufferPointer)
  func finalize() -> Self.Digest
}
extension HashFunction {
  @inlinable internal static func hash(bufferPointer: Swift.UnsafeRawBufferPointer) -> Self.Digest {
        var hasher = Self()
        hasher.update(bufferPointer: bufferPointer)
        return hasher.finalize()
    }
  @inlinable public static func hash<D>(data: D) -> Self.Digest where D : Foundation.DataProtocol {
        var hasher = Self()
        hasher.update(data: data)
        return hasher.finalize()
    }
  @inlinable public mutating func update<D>(data: D) where D : Foundation.DataProtocol {
        data.regions.forEach { (regionData) in
            regionData.withUnsafeBytes({ (dataPtr) in
                self.update(bufferPointer: dataPtr)
            })
        }
    }
}
extension AES {
  public enum GCM {
    public static func seal<Plaintext, AuthenticatedData>(_ message: Plaintext, using key: CryptoKit.SymmetricKey, nonce: CryptoKit.AES.GCM.Nonce? = nil, authenticating authenticatedData: AuthenticatedData) throws -> CryptoKit.AES.GCM.SealedBox where Plaintext : Foundation.DataProtocol, AuthenticatedData : Foundation.DataProtocol
    public static func seal<Plaintext>(_ message: Plaintext, using key: CryptoKit.SymmetricKey, nonce: CryptoKit.AES.GCM.Nonce? = nil) throws -> CryptoKit.AES.GCM.SealedBox where Plaintext : Foundation.DataProtocol
    public static func open<AuthenticatedData>(_ sealedBox: CryptoKit.AES.GCM.SealedBox, using key: CryptoKit.SymmetricKey, authenticating authenticatedData: AuthenticatedData) throws -> Foundation.Data where AuthenticatedData : Foundation.DataProtocol
    public static func open(_ sealedBox: CryptoKit.AES.GCM.SealedBox, using key: CryptoKit.SymmetricKey) throws -> Foundation.Data
  }
}
extension AES.GCM {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct SealedBox {
    public var tag: Foundation.Data {
      get
    }
    public var ciphertext: Foundation.Data {
      get
    }
    public var nonce: CryptoKit.AES.GCM.Nonce {
      get
    }
    public var combined: Foundation.Data? {
      get
    }
    @usableFromInline
    internal init(combined: Foundation.Data)
    @inlinable public init<D>(combined: D) throws where D : Foundation.DataProtocol {
            // AES minumum nonce (12 bytes) + AES tag (16 bytes)
            // While we have these values in the internal APIs, we can't use it in inlinable code.
            let aesGCMOverhead = 12 + 16
            
            if (combined.count < aesGCMOverhead) {
                throw CryptoKitError.incorrectParameterSize
            }
            
            self.init(combined: Data(combined))
        }
    public init<C, T>(nonce: CryptoKit.AES.GCM.Nonce, ciphertext: C, tag: T) throws where C : Foundation.DataProtocol, T : Foundation.DataProtocol
  }
}
extension P256.Signing {
  public struct ECDSASignature : Foundation.ContiguousBytes {
    public var rawRepresentation: Foundation.Data
    public init<D>(rawRepresentation: D) throws where D : Foundation.DataProtocol
    public init<D>(derRepresentation: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var derRepresentation: Foundation.Data {
      get
    }
  }
}
extension P256.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> CryptoKit.P256.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension P256.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> CryptoKit.P256.Signing.ECDSASignature where D : Foundation.DataProtocol
}
extension P256.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P256.Signing.ECDSASignature, for digest: D) -> Swift.Bool where D : CryptoKit.Digest
}
extension P256.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P256.Signing.ECDSASignature, for data: D) -> Swift.Bool where D : Foundation.DataProtocol
}
extension P384.Signing {
  public struct ECDSASignature : Foundation.ContiguousBytes {
    public var rawRepresentation: Foundation.Data
    public init<D>(rawRepresentation: D) throws where D : Foundation.DataProtocol
    public init<D>(derRepresentation: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var derRepresentation: Foundation.Data {
      get
    }
  }
}
extension P384.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> CryptoKit.P384.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension P384.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> CryptoKit.P384.Signing.ECDSASignature where D : Foundation.DataProtocol
}
extension P384.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P384.Signing.ECDSASignature, for digest: D) -> Swift.Bool where D : CryptoKit.Digest
}
extension P384.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P384.Signing.ECDSASignature, for data: D) -> Swift.Bool where D : Foundation.DataProtocol
}
extension P521.Signing {
  public struct ECDSASignature : Foundation.ContiguousBytes {
    public var rawRepresentation: Foundation.Data
    public init<D>(rawRepresentation: D) throws where D : Foundation.DataProtocol
    public init<D>(derRepresentation: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var derRepresentation: Foundation.Data {
      get
    }
  }
}
extension P521.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> CryptoKit.P521.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension P521.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> CryptoKit.P521.Signing.ECDSASignature where D : Foundation.DataProtocol
}
extension P521.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P521.Signing.ECDSASignature, for digest: D) -> Swift.Bool where D : CryptoKit.Digest
}
extension P521.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P521.Signing.ECDSASignature, for data: D) -> Swift.Bool where D : Foundation.DataProtocol
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SharedSecret : Foundation.ContiguousBytes {
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public func x963DerivedSymmetricKey<H, SI>(using hashFunction: H.Type, sharedInfo: SI, outputByteCount: Swift.Int) -> CryptoKit.SymmetricKey where H : CryptoKit.HashFunction, SI : Foundation.DataProtocol
  public func hkdfDerivedSymmetricKey<H, Salt, SI>(using hashFunction: H.Type, salt: Salt, sharedInfo: SI, outputByteCount: Swift.Int) -> CryptoKit.SymmetricKey where H : CryptoKit.HashFunction, Salt : Foundation.DataProtocol, SI : Foundation.DataProtocol
}
extension SharedSecret : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SharedSecret : Swift.CustomStringConvertible, Swift.Equatable {
  public static func == (lhs: CryptoKit.SharedSecret, rhs: CryptoKit.SharedSecret) -> Swift.Bool
  public static func == <D>(lhs: CryptoKit.SharedSecret, rhs: D) -> Swift.Bool where D : Foundation.DataProtocol
  public var description: Swift.String {
    get
  }
}
extension Insecure {
  public struct SHA1 {
    @available(iOS 13.2, OSX 10.15, watchOS 6.1, tvOS 13.2, *)
    public static var blockByteCount: Swift.Int
    public typealias Digest = CryptoKit.Insecure.SHA1Digest
    public static var byteCount: Swift.Int
    public init()
    public mutating func update(bufferPointer: Swift.UnsafeRawBufferPointer)
    public func finalize() -> CryptoKit.Insecure.SHA1.Digest
  }
  public struct MD5 {
    @available(iOS 13.2, OSX 10.15, watchOS 6.1, tvOS 13.2, *)
    public static var blockByteCount: Swift.Int
    public typealias Digest = CryptoKit.Insecure.MD5Digest
    public static var byteCount: Swift.Int
    public init()
    public mutating func update(bufferPointer: Swift.UnsafeRawBufferPointer)
    public func finalize() -> CryptoKit.Insecure.MD5.Digest
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public protocol MessageAuthenticationCode : Foundation.ContiguousBytes, Swift.CustomStringConvertible, Swift.Hashable, Swift.Sequence where Self.Element == Swift.UInt8 {
  var byteCount: Swift.Int { get }
}
extension MessageAuthenticationCode {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public static func == <D>(lhs: Self, rhs: D) -> Swift.Bool where D : Foundation.DataProtocol
  public func makeIterator() -> Swift.Array<Swift.UInt8>.Iterator
  public var description: Swift.String {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum CryptoKitError : Swift.Error {
  case incorrectKeySize
  case incorrectParameterSize
  case authenticationFailure
  case underlyingCoreCryptoError(error: Swift.Int32)
}
extension Curve25519 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public var rawRepresentation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init()
      public var publicKey: CryptoKit.Curve25519.KeyAgreement.PublicKey {
        get
      }
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.Curve25519.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
      public var rawRepresentation: Foundation.Data {
        get
      }
    }
  }
}
extension Curve25519 {
  public enum Signing {
    public struct PrivateKey {
      public init()
      public var publicKey: CryptoKit.Curve25519.Signing.PublicKey {
        get
      }
      public init<D>(rawRepresentation data: D) throws where D : Foundation.ContiguousBytes
      public var rawRepresentation: Foundation.Data {
        get
      }
    }
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public var rawRepresentation: Foundation.Data {
        get
      }
    }
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA256Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA384Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA512Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.Insecure.SHA1Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.Insecure.MD5Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA256 : CryptoKit.HashFunction {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA384 : CryptoKit.HashFunction {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA512 : CryptoKit.HashFunction {}
extension CryptoKit.Insecure.SHA1 : CryptoKit.HashFunction {}
extension CryptoKit.Insecure.MD5 : CryptoKit.HashFunction {}
